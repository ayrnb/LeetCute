# 📈 从零开始优化矩阵乘法：一步步提升性能 10 倍！
## 🧠 背景简介
矩阵乘法是深度学习、图像处理、科学计算等领域中最基础且最频繁的操作之一。标准的三重循环实现虽然直观，但在现代 CPU 架构下性能往往不尽人意。
本文通过一个完整的 C 语言实现案例，一步步理解如何通过调整循环顺序、减少重复访存、利用指针访问等方式，将原始的矩阵乘法性能提升数倍甚至十倍以上。
## 运行方式
 ```
cd LeetCute
make
 ./gemm/gemm
 ```
---
### 🧮 原始实现（i-l-j）
```
for (int i = 0; i < m; ++i) {
    for (int l = 0; l < k; ++l) {
        for (int j = 0; j < n; ++j) {
            C[i * n + j] += A[i * k + l] * B[l * n + j];
        }
    }
}
```
#### 🔍 存在的问题：
- B[l][j] 是列访问，不符合 CPU cache 行优先的设计；
- 每次都要重复计算地址 A[i * k + l] 和 B[l * n + j]；
- 缺乏数据复用性，导致大量 cache miss；

---
### 🚀 第一次优化：提取局部变量（v1）
```
for (int l = 0; l < k; ++l) {
    for (int i = 0; i < m; ++i) {
        float a_val = A[i * k + l];
        for (int j = 0; j < n; ++j) {
            C[i * n + j] += a_val * B[l * n + j];
        }
    }
}
```
#### ✅ 改进点：
- 将 A[i][l] 提取为局部变量 a_val，避免重复读取；
- 内层对 B[l][j] 的访问变为连续行访问；
- 更利于编译器识别向量化机会；

---
### 🚀 第二次优化：使用指针访问（v2）

```
for (int l = 0; l < k; ++l) {
    const float* b_row = &B[l * n];
    for (int i = 0; i < m; ++i) {
        float a_val = A[i * k + l];
        float* c_row = &C[i * n];
        for (int j = 0; j < n; ++j) {
            c_row[j] += a_val * b_row[j];
        }
    }
}
```
#### ✅ 改进点：
- 提前取出 B[l][j] 行指针 b_row；
- 使用指针 c_row 直接访问 C[i][j]；
- 减少地址计算次数；
- 连续内存访问更利于 cache 利用率和 SIMD 向量化；
🔸 手动展开内层循环
```
for (int j = 0; j < n; j += 4) {
    c_row[j+0] += a_val * b_row[j+0];
    c_row[j+1] += a_val * b_row[j+1];
    c_row[j+2] += a_val * b_row[j+2];
    c_row[j+3] += a_val * b_row[j+3];
}
```
## GPU

### baseline
---

## ⏱️ 性能对比（m=n=k=2048）

v0 time: 24.486 s \
v1 time: 22.499 s \
v2 time: 14.890 s \
v3 time: 11.682 s \
v4 time: 0.061630 s
---
### 🧪 技术原理分析
1. 内存访问模式决定性能
- CPU cache 是按“行”缓存设计的；
- 非连续访问会导致 cache miss；
- 优化后变为连续访问，命中率大幅提升；
2. 减少重复地址计算
- 原始版本中 A[i * k + l] 和 B[l * n + j] 在每次内层循环都要重新计算；
- 提前提取指针或局部变量可大幅减少冗余运算；
3. 便于后续向量化和并行化
- 最内层循环变成连续访存，更容易被编译器识别为可向量化；
- 可进一步手动加入 SIMD 指令（如 SSE/AVX）加速；

---
🧩 扩展建议
可以在此基础上继续优化：
🔸 分块 tile-based 优化（GEMM 核心技巧）
- 将大矩阵拆成小块；
- 提高数据复用率；
- 更适合多级 cache 架构；

---
📦 完整代码复现
---
📝 总结一句话：
通过调整循环顺序、减少重复访存、利用指针访问等简单手段，我们可以在不改变逻辑的前提下，让矩阵乘法性能提升 3~10 倍，这正是高性能计算中的核心思想之一。
